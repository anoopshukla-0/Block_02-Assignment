=========================================
ğŸš€ JavaScript Deep Clone Notes
=========================================

ğŸ§© SECTION 1: ğŸ“Œ QUESTION
-----------------------------------------

ğŸ“– Now it's time to do some reading (Doc Link)  
Really hoping you read the article â€” it's very imperative for the following problem.

---

ğŸ“ PROBLEM STATEMENT:

Write a function `deepClone(obj)` that creates a deep copy of a given object 
using `JSON.stringify()` and `JSON.parse()`.

The function should ensure that modifying the cloned object does NOT affect 
the original object.

---

ğŸ’¡ Example Input:

{
  name: "Alice",
  hobbies: ["reading", "traveling"]
}

---

ğŸ’¡ Example Output (After modifying the clone):

Original: { name: "Alice", hobbies: ["reading", "traveling"] }

Clone:    { name: "Alice", hobbies: ["reading", "traveling", "coding"] }

---

=========================================
ğŸ“– SECTION 2: SELF LEARNING
=========================================

ğŸ” WHAT IS DEEP CLONING?

Deep cloning means creating a COMPLETE and INDEPENDENT copy of an object,
including all its nested objects and arrays.

ğŸ“¦ The goal is: 
   â¤ Modify the copy âœ…
   â¤ Original stays safe & untouched âœ…

----------------------------------------------------
ğŸ“Œ WHY DO WE NEED IT?

Because in JavaScript, objects are assigned by reference.
If you copy an object directly, both variables will point to the same memory!

Example:
-------------
let original = { name: "Anoop" };
let copy = original;

copy.name = "Shyam";

console.log(original.name); // ğŸ”´ Outputs: "Shyam" â€” Oops! Reference shared.

----------------------------------------------------
âœ… SOLUTION: Use JSON.stringify() + JSON.parse()

ğŸ›  Method:
-------------
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

ğŸ’¡ This creates a completely new object with no link to the original.

----------------------------------------------------
âš ï¸ LIMITATIONS OF THIS METHOD:

This approach works well with plain JavaScript objects, but it does NOT support:
   âŒ Date objects
   âŒ Functions
   âŒ undefined values
   âŒ RegExp, Map, Set
   âŒ Circular references

ğŸ“Œ Example of failure:
   JSON.stringify({ name: "Anoop", createdAt: new Date() });
   // Date will be converted to a string â€” â— not preserved

----------------------------------------------------
ğŸ§ª EXAMPLE: Using deepClone()

const original = {
  name: "Alice",
  hobbies: ["reading", "traveling"]
};

const clone = deepClone(original);
clone.hobbies.push("coding");

console.log("Original:", original);
// Output: { name: 'Alice', hobbies: ['reading', 'traveling'] }

console.log("Clone:", clone);
// Output: { name: 'Alice', hobbies: ['reading', 'traveling', 'coding'] }

ğŸ¯ Mission accomplished: Clone is safe to mutate! ğŸ’¥

----------------------------------------------------
ğŸ’ BEST PRACTICE:

Use this method when:
   âœ… Data is JSON-compatible
   âœ… Performance is not a major concern
   âœ… Simplicity and speed matter

For complex structures or deep types â†’ Use libraries like:
   ğŸ”¸ Lodash â†’ _.cloneDeep(obj)
   ğŸ”¸ StructuredClone API (modern browsers)
   ğŸ”¸ Manual recursive cloning

----------------------------------------------------